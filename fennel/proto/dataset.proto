syntax = "proto3";

package fennel.proto;

import "status.proto";
import "source.proto";

// All integers representing time are in microseconds and hence should be int64.

message Field {
  string name = 1;
  // Arrow type
  bytes dtype = 2;
  bool is_key = 3;
  bool is_timestamp = 4;
  string owner = 5;
  string description = 6;
  bool is_nullable = 7;
  repeated string tags = 8;
}

message PullLookup {
  string function_source_code = 1;
  bytes function = 2;
}

message CreateDatasetRequest {
  string name = 1;
  repeated Field fields = 2;
  repeated Pipeline pipelines = 3;
  repeated DataConnector input_connectors = 4;
  repeated DataConnector output_connectors = 5;

  string signature = 6;
  string owner = 7;
  string description = 8;
  // Default mode is pandas.
  string mode = 9;
  uint32 version = 10;

  // Serialized arrow schema.
  bytes schema = 11;
  int64 retention = 12;
  int64 max_staleness = 13;

  PullLookup pull_lookup = 14;
}

message CreateDatasetResponse{
  string name = 1;
  Status status = 2;
}

//----------------------------------------------------------------------------------------------
// Pipeline
//----------------------------------------------------------------------------------------------

message Pipeline {
  // Nodes in the pipeline.
  repeated Node nodes = 1;
  // Id of the root node.
  string root = 2;
  string signature = 3;
  // List of input datasets.
  repeated string inputs = 4;
}

// Each Node in the pipeline either refers to a dataset or an operator.
// Each node also has a globally unique id. Operators refer to their inputs via
// their corresponding node ids.
message Node {
  string id = 1;
  oneof node {
    Operator operator = 2;
    string dataset_name = 3;
  }
}

message Operator {
  oneof op {
    Aggregate aggregate = 1;
    Join join = 2;
    Transform transform = 3;
    Union union = 4;
  }
}

message Aggregate {
  string operand_node_id = 1;
  repeated string keys = 2;
  repeated Aggregation aggregates = 3;
}

message Join {
  string lhs_node_id = 1;
  // RHS of a JOIN can only be a dataset.
  string rhs_dataset_name = 2;
  // Map of left field name to right field name to join on.
  map<string, string> on = 3;
}

message Transform {
  string operand_node_id = 1;
  bytes function = 2;
  string function_source_code = 3;
  string timestamp_field = 4;
}

message Union {repeated string operand_node_ids = 1;}

// ----------------------------------------------------------------------------
// Aggregate Definitions
// ----------------------------------------------------------------------------

message Aggregation {
  AggregateType type = 1;
  WindowSpec window_spec = 2;
  oneof config {
    string value_field = 3;
    TopKConfig topk = 4;
    CFConfig cf = 5;
  }
}

enum AggregateType {
  SUM = 0;
  AVG = 1;
  COUNT = 2;
  MIN = 3;
  MAX = 4;
  TOPK = 5;
  CF = 6;
}

// to = 0 represents last X window.
message Window {
  int64 start = 1;
  int64 end = 2;
}

message DeltaWindow {
  Window baseline = 1;
  Window target = 2;
}

message WindowSpec {
  oneof spec {
    bool forever_window = 1;
    Window window = 2;
    DeltaWindow delta_window = 3;
  }
}

message TopKConfig {
  int32 k = 1;
  repeated string item_fields = 2;
  string score_field = 3;
}

message CFConfig {
  int32 limit = 1;
  repeated string context_fields = 2;
  string weight_field = 3;
}
